/****************************************************************************** * Numonyx™ 128 Mbit EMBEDDED FLASH MEMORY J3 Version D                       * ****************************************************************************** * REFERENCES                                                                 * *  [1] Numonyx™ Embedded Flash Memory(J3 v. D) Datasheet Revision 5          * *                                                                            * ****************************************************************************** * Copyright (C)2011  Mathias Hörtnagl <mathias.hoertnagl@gmail.com>          * *                                                                            * * This program is free software: you can redistribute it and/or modify       * * it under the terms of the GNU General Public License as published by       * * the Free Software Foundation, either version 3 of the License, or          * * (at your option) any later version.                                        * *                                                                            * * This program is distributed in the hope that it will be useful,            * * but WITHOUT ANY WARRANTY; without even the implied warranty of             * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              * * GNU General Public License for more details.                               * *                                                                            * * You should have received a copy of the GNU General Public License          * * along with this program.  If not, see <http://www.gnu.org/licenses/>.      * ******************************************************************************/#include "stddef.h"#ifndef _FLASH_H#define _FLASH_H/* Flash memory location */#define FLASH_MEMORY ((volatile uchar *) 0x10000000)/* Flash status register flags. */#define FLASH_READY             ((uint) 0x80) // Bit 8: Flash is ready. #define FLASH_ERASE_ERROR       ((uint) 0x20) // Bit 5: Error while errasing.#define FLASH_PROGRAM_ERROR     ((uint) 0x10) // Bit 4: Error while programming.#define FLASH_CMD_ERROR         (FLASH_ERASE_ERROR | FLASH_PROGRAM_ERROR)#define FLASH_BLOCK_LOCKED      ((uint) 0x02) // Bit 2: Block is locked./* Status register commands */#define CMD_READ_SR             ((uint) 0x70) // Read the status register.#define CMD_CLEAR_SR            ((uint) 0x50) // Clear error states./* Memory operations */#define CMD_READ_ARRAY          ((uint) 0xff) // Read 32bit of data.#define CMD_BYTE_PROGRAM        ((uint) 0x10) // Write one byte of data.#define CMD_BLOCK_ERASE_SETUP   ((uint) 0x20) // Setup erase command.#define CMD_BLOCK_ERASE_CONFIRM ((uint) 0xd0) // Confirm errase command./* Memory size */#define FLASH_BLOCK_SIZE         131072       // Size of one block in bytes.#define FLASH_BLOCKS             128          // Number of blocks available./* Read the status register. */extern uchar flash_read_status();/* Clear the status register.    The Status Register (SR) contain status and error bits which are set by the    device. SR status bits are cleared by the device, however SR error bits are    cleared by issuing the Clear Status Register command. Resetting the device    also clears the Status Register. */extern void flash_clear_sr();/* Write a byte of data to a specific device address.    Writing only changes '1' to '0'. If you overwrite data that would change '0'   to '1', erase the block beforhand.   Issuing the Read Array command to the device while it is actively programming    causes subsequent reads from the device to output invalid data. [1] */extern void flash_write(uint adr, uchar b);/* Read 32bit of data from a specific device address.    Issues a Read Array Command each time, although device stays in Array Read   mode until another command operation takes place. */extern uint flash_read(uint adr);/* Erase block. Point to an address within the block address space you want to   erase. 16 Mbytes or 8 Mword (128-Mbit), organized as 128-Kbyte erase blocks.   Erasing is performed on a block basis - an entire block is erased each time    an erase command sequence is issued. Once a block is fully erased, all    addressable locations within that block read as logical ones (FFFFh). [1] */extern void flash_block_erase(uint blk);/* Wait for the end of a operation and return the status register when ready.    Block erasure and writing data takes longer than a WB write operation.    So after each erase or write call flash_wait() or do something else    meanwhile. */extern uchar flash_wait();#endif